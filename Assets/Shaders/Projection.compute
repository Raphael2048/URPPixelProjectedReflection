// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Clear
#pragma kernel Project

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Function.hlsl"


RWTexture2D<uint> _IntermediateTexture;
Texture2D<float> _CameraDepthTexture;
float4 _TextureSize;
float3 _WSCameraPos;
float4 _ReflectionPlane;
float4x4 _WorldToClipMatrix;
float4x4 _ClipToWorldMatrix;


[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    if(all(id.xy < (uint2)(_TextureSize.xy)))
    {
        _IntermediateTexture[id.xy] = PROJECTION_CLEAR_VALUE;
    }
}

void ProjectionPassWrite(int2 ReflectedPixel, float2 ReflectingCoord)
{
//     int2 P = floor(ReflectingCoord);
//     _IntermediateTexture[P] = float4(1, 0, 0, 1);
    for(int y = 0; y < 2; ++y)
    {
        for(int x = 0; x < 2; ++x)
        {
            int2 ReflectingPixel = floor(ReflectingCoord + float2(x, y));
            int2 PixelOffset = ReflectingPixel - ReflectedPixel;
            
            uint Value = EncodeProjectionBufferValue(PixelOffset);
//             _IntermediateTexture[ReflectingPixel] = float4(1, 0,  0, 1);
            InterlockedMin(_IntermediateTexture[ReflectingPixel], Value);
        }
    }
}

[numthreads(8, 8, 1)]
void Project (uint3 id : SV_DispatchThreadID)
{
    if(all(id.xy < (uint2)(_TextureSize.xy)))
    {
        float2 uv = (id.xy + 0.5) * _TextureSize.zw;
        float depth = _CameraDepthTexture.Load(int3(id.xy, 0));
        #ifdef UNITY_REVERSED_Z
            if(depth == 0)
        #else
            if(depth == 1)
        #endif
        return;
        float3 ndc = float3(uv * 2 - 1, depth);
        
        // 被反射的目标点的世界坐标
        float4 wpos = mul(_ClipToWorldMatrix, float4(ndc, 1));
        wpos /= wpos.w;
        
        float distance = dot(_ReflectionPlane, wpos);
        if(distance > 0.01)
        {
            float3 MirroredPosition = wpos.xyz - _ReflectionPlane.xyz * (2 * distance);
            float4 MirroredNDC = mul(_WorldToClipMatrix, float4(MirroredPosition, 1));
            float2 MirroredUV = MirroredNDC.xy / MirroredNDC.w;
            
            if(all(abs(MirroredUV) < 1.0f))
            {
                float2 MirroredPixelCoord = (MirroredUV * 0.5f + 0.5f) * _TextureSize.xy;
                ProjectionPassWrite(id.xy, MirroredPixelCoord);
//                 int2 ReflectingPixel = floor(ReflectingCoord + float2(x, y));
//                 int2 Mirrored = floor(MirroredPixelCoord);
//                 int2 PixelOffset = MirroredPixelCoord - id.xy;
//                 _IntermediateTexture[Mirrored] = float4(abs(PixelOffset) / 100.0f, 0, 1);
//                 _IntermediateTexture[Mirrored] = float4(1, 0, 0, 1);
            }
            
        }
        
    }

}
